// barbers.cc
//
// Simulate the sleeping barbers problem.
//
// Author: Morris Bernstein
// Copyright 2019, Systems Deployment, LLC.
#include <algorithm>
#include <cassert>
#include <chrono>
#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <pthread.h>
#include <queue>
#include <random>
#include <time.h>
#include <unistd.h>
#include <vector>

using namespace std;

const char* PROG_NAME = "";


class Shop;
class Barber;
class Customer;


bool shopOpen = true; //determined if the shop is opened or is closed.

class Lock {
public:
  Lock(pthread_mutex_t* mutex): mutex(mutex) {
    int rc = pthread_mutex_lock(this->mutex);
    if (rc < 0) {
      perror("can't lock mutex");
      exit(EXIT_FAILURE);
    }
  }

  ~Lock() {
    int rc = pthread_mutex_unlock(mutex);
    if (rc < 0) {
      perror("can't unlock mutex");
      exit(EXIT_FAILURE);
    }
  }

private:
  pthread_mutex_t* mutex;
};


class Shop {
public:
  struct BarberOrWait {
    Barber* barber;		// Barber is available
    bool chair_available;	// If barber isn't available,
				// waiting chair is available.
  };

  // Constructor initializes shop and creates Barber threads (which
  // will immediately start calling next_customer to fill the
  // collection of sleeping barbers).
  Shop(int n_barbers, unsigned waiting_chairs, int average_service_time,
        int service_time_deviation, int average_customer_arrival, int duration);

  // Main thread: open the shop and spawn customer threads until
  // closing time.  Report summary statistics for the day.
  void run();

  // Customer thread announces arrival to shop. If the collection of
  // currently sleeping barbers is not empty, remove and return one
  // barber from the collection. If all the barbers are busy and there
  // is an empty chair in the waiting room, add the customer to the
  // waiting queue and return {nullptr, true}.  Otherwise, the
  // customer will leave: return {nullptr, false}.
  BarberOrWait arrives(Customer* customer);

  // Barber thread requests next customer.  If no customers are
  // currently waiting, add the barber to the collection of
  // currently sleeping barbers and return nullptr.
  Customer* next_customer(Barber* barber);

  // Return random service time.
  int service_time();

  // Return random customer arrival.
  int customer_arrival_time();



private:

  vector<pthread_t*> barber_threads;
  vector<pthread_t*> customer_threads;
  struct timespec time_limit;

  int customers_served_immediately;
  int customers_waited;
  int customers_turned_away;
  int customers_total;

  //The number of barbers in the shop
  int numBarbersWorking;
  //The number of waiting chairs we have
  unsigned waitingChairs;
  
  //stores average service time to use with the service_time()
  int averageServiceTime;
  
  //stores std. deviation to use with the service_time()
  int serviceTimeDeviation;
  
  //generated by the customer_arrival_time()
  int averageCustomerArrival;
  
  //length of the simulation/run
  int simulationDuration;

  pthread_mutex_t *shopMutex;       //Mutex for shop operations.

  queue<Barber*>   barberQueue;
  queue<Customer*> customerQueue;

  //Include a shop mutex

};


class Barber {
public:
  Barber(Shop* shop, int id);

  // Barber thread function.
  void run();

  // Shop tells barber it's closing time.
  void closing_time();

  // Customer wakes up barber.
  void awaken(Customer* customer);

  // Customer sits in barber's chair.
  void customer_sits();

  // Customer proffers payment.
  void payment();

  const int id;
  

private:
  Shop* shop;

  pthread_mutex_t *barberMutex;       //Mutex for barber operations.
  pthread_cond_t *barberCondition;    //Condition (signal) for barber operations

  int barberState = 0;                       //to determine the state that a barber is in
  Customer* assignedCustomer;                //Customer* that points to customer this barber is working on

};


class Customer {
public:
  Customer(Shop* shop, int id);
  ~Customer();

  // Customer thread function.
  void run();

  // Barber calls this customer after checking the waiting-room
  // queue (customer should be waiting).
  void next_customer(Barber* barber);

  // Barber finishes haircut (Customer should be receiving haircut).
  void finished();

  // Barber has accepted payment for service.
  void payment_accepted();

  const int id;
  Barber* assignedBarber;                     //Barber* that points to the barber working with this customer object.


private:
  Shop* shop;
  pthread_mutex_t *customerMutex;      //mutex for cusotmer operations
  pthread_cond_t *customerCondition;   //condition (signal) for customer operations
  int customerState = 0;                      //internal variable to determine the state of the customer
};


// Barber thread.  Must be joined by Shop thread to allow shop to
// determine when barbers have left.
void* run_barber(void* arg) {
  Barber* barber = reinterpret_cast<Barber*>(arg);
  barber->run();
  return nullptr;
}


// Customer thread.  Runs in detatched mode so resources are
// automagically cleaned up when customer leaves shop.
void* run_customer(void* arg) {
  Customer* customer = reinterpret_cast<Customer*>(arg);
  customer->run();
  delete customer; //Deallocating memory for the customer
  return nullptr;
}

//------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------Shop::Shop-------------------------------------------------------
//------------------------------------------------------------------------------------------------------------------------
Shop::Shop(int n_barbers, unsigned int waiting_chairs, int average_service_time, int service_time_deviation,
          int average_customer_arrival, int duration){

  //Ive created all these private varibles inside the Shop class to hold the values we use to initialize.
  numBarbersWorking = n_barbers;
  waitingChairs = waiting_chairs;
  averageServiceTime = average_service_time;
  serviceTimeDeviation = service_time_deviation;
  averageCustomerArrival = average_customer_arrival;
  simulationDuration = duration;

  shopMutex = (pthread_mutex_t *) malloc(sizeof(pthread_mutex_t));
  *shopMutex = PTHREAD_MUTEX_INITIALIZER;

  int rc = clock_gettime(CLOCK_REALTIME, &time_limit);
  if (rc < 0) {
    perror("reading realtime clock");
    exit(EXIT_FAILURE);
  }
  // Round to nearest second
  time_limit.tv_sec += duration + (time_limit.tv_nsec >= 500000000); //500,000,000. 500 millon nano seconds = 0.5 second
  time_limit.tv_nsec = 0;


  for(int i = 0; i < numBarbersWorking; i++){
    Barber *newBarber = new Barber(this,i); //create barber objects

    pthread_t* barberThread = reinterpret_cast<pthread_t*>(calloc(1, sizeof(pthread_t)));
      int rc = pthread_create(barberThread, nullptr,run_barber, reinterpret_cast<void *>(newBarber));

      if (rc != 0) {
        errno = rc;
        perror("Failed creating barberThread pthread");
        exit(EXIT_FAILURE);
      }
      else{
        cout << "Barber " << newBarber->id << " arrives for work" << endl;
        barber_threads.push_back(barberThread);
        //barberQueue.push(newBarber);
        //cout << "shop constructor barberQueue size: " << barberQueue.size() << endl;
      }
  }
}


//------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------Shop::run-------------------------------------------------------
//------------------------------------------------------------------------------------------------------------------------
void Shop::run(){
  cout << "the shop opens" << endl;
  int numberOfTotalCustomers = 0;

  for (int next_customer_id = 0; ; next_customer_id++) {
    struct timespec now;
    int rc = clock_gettime(CLOCK_REALTIME, &now);
    if (rc < 0) {
      perror("reading realtime clock");
      exit(EXIT_FAILURE);
    }
    if (now.tv_sec >= time_limit.tv_sec) {
      // Shop closes.
      numberOfTotalCustomers = next_customer_id; //When we break the loop, record how many customers we had.
      break;
    }

    // Wait for random delay, then create new Customer thread.
    usleep(customer_arrival_time());//waiting for a random delay based on the customer_arrival_time function

    //Here I am going to create my customerThreads
    //When I call pthtread_create, I am going to make sure I create my customer threads in detached mode.
    //Creating a new Customer object.
    Customer *customer = new Customer (this,next_customer_id);

    pthread_t* customerThread = reinterpret_cast<pthread_t*>(calloc(1, sizeof(pthread_t)));
      int customerThreadRC = pthread_create(customerThread, nullptr,run_customer, reinterpret_cast<void *>(customer));
      
      if (customerThreadRC != 0) {
        errno = customerThreadRC;
        perror("Failed creating cusotmerThread pthread");
        exit(EXIT_FAILURE);
      }
      else{
          pthread_detach(*customerThread);
      }
  }
  

  cout << "the shop closes" << endl;
  shopOpen = false; 

  for (auto thread: barber_threads) {
    pthread_join(*thread, nullptr);
  }

  customers_total = numberOfTotalCustomers;

  cout << "Customers served immediately: " << customers_served_immediately << endl;
  cout << "Customers waited: " << customers_waited << endl;
  cout << "Total customers served: " << (customers_served_immediately + customers_waited) << endl;
  cout << "Customers turned away: " << customers_turned_away << endl;
  cout << "Total customers: " << customers_total << endl;
}

//------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------Shop::arrives-------------------------------------------------------
//------------------------------------------------------------------------------------------------------------------------
Shop::BarberOrWait Shop::arrives(Customer* customer) {
  Lock shopLock(shopMutex);                 //Lock teh shop mutex
  Barber* tempBarber;                       //Makes returning a struct a little cleaner
  
  if(barberQueue.empty() == false){         //If we break in here, there is a barber available 
                                            //as he is sleeping

    customerQueue.push(customer);           //Add the customer to the customerQueue

    tempBarber = barberQueue.front();       //Connect the barber and customer objects.

    barberQueue.pop();                      //pop the front of the barber queue

    customers_served_immediately++;         //Increment out counter

    return BarberOrWait{tempBarber,true};   //Return
  }

  //If there is no available barber, check the waiting chairs
  else if(barberQueue.empty() == true && customerQueue.size() < waitingChairs){
    
    customerQueue.push(customer);           //Add the customer to waitingQueue

    customers_waited++;                    //Increment the fact that we had a customer wait.

    cout << "Customer " << customer->id << " takes a seat in the waiting room." << endl;

    return BarberOrWait{nullptr,true};           
  }
  
  // Otherwise, customer leaves.
    cout << "Customer " << customer->id << " leaves without getting a haircut." << endl;

    customers_turned_away++;                //Incremenet counter

    return BarberOrWait{nullptr, false};
}


//------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------Shop::next_customer-------------------------------------------------------
//------------------------------------------------------------------------------------------------------------------------
Customer* Shop::next_customer(Barber* barber) {
  Lock shopLock(shopMutex);
  Customer* returnCustomer;
  
//We are reading/writing shared queues. Need to lock shop mutex.

  if(customerQueue.empty() == false){       //If the customerQueue IS NOT empty. Meaning there are customers
    returnCustomer = customerQueue.front(); //return the front of the queue
    customerQueue.pop();                    //Remove the customer from the customerQueue
//    barberQueue.pop();                      //Remove the barber from the queue
    return returnCustomer;
  }

  else{                                         //If the customerQueue IS empty, barber takes a nap.
    cout << "Barber " << barber->id << " takes a nap" << endl;
    this->barberQueue.push(barber);             //Return the barber to the barberQueue
    return nullptr;
  }
}

//------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------Shop::service_time-------------------------------------------------------
//------------------------------------------------------------------------------------------------------------------------
int Shop::service_time() {
  int serviceTime = 0;

  //std::normal_distribution<int> normalDistribution(1.2,0.2);
  std::normal_distribution<float> normalDistribution((this->averageServiceTime),(this->serviceTimeDeviation)); 
  std::default_random_engine randomGenerator;

  serviceTime = (int)normalDistribution(randomGenerator);

  return serviceTime;
}


//------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------Shop::customer_arrival_time-------------------------------------------------------
//------------------------------------------------------------------------------------------------------------------------
int Shop::customer_arrival_time() {
  int customerArrival = 0;

  //std::poisson_distribution<int> poissonDistribution(0.4);
  std::poisson_distribution<int> poissonDistribution((this->averageCustomerArrival));
  std::default_random_engine randomGenerator;

  customerArrival = poissonDistribution(randomGenerator);

  return customerArrival;
}


//------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------Barber::Barber-------------------------------------------------------
//------------------------------------------------------------------------------------------------------------------------
Barber::Barber(Shop* shop, int id):id(id){
  this->shop = shop;

  //allocate memory for Barber mutex
  barberMutex = (pthread_mutex_t *) malloc(sizeof(pthread_mutex_t));
  *barberMutex = PTHREAD_MUTEX_INITIALIZER;

  //allocating memory for the barber condition variable
  barberCondition = (pthread_cond_t * )malloc(sizeof(pthread_cond_t));
  *barberCondition = PTHREAD_COND_INITIALIZER;

}

//------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------Barber::run-------------------------------------------------------
//------------------------------------------------------------------------------------------------------------------------
void Barber::run() {                                   
  while (true){           //Barbers work until the termination of the shop.

  this->barberState = 0;      //Resetting the state variable for a barber

  Customer *myCustomer;

    //{ //We dont need a lock here, as the next_customer function manipualtes data of the shop.
    myCustomer = shop->next_customer(this);

    //here is where you need to wait for myCustomer to become not nullptr

    if(myCustomer == nullptr){ //If we dont have a customer. we wait on being awoken.
      
      Lock lock (barberMutex);
      while(barberState != 1 && shopOpen/*&& shop is not closed*/){
          pthread_cond_wait(barberCondition, barberMutex);
      }
      //By this point, the cusotmer has called awaken.
      //We only get barberState = 1 when awaken is called in the customer thread

      myCustomer = this->assignedCustomer;
      cout << "Customer " << myCustomer->id << " wakes Barber " << this->id << "." << endl;
    
    } else{
      //this means you have a customer in the shop.
      //the shop has told you who your customer is.
      //so there is a customer in the waiting room chair
      //this means that shop::bext_customer returned a valid customer pointer.

      myCustomer->next_customer(this); //This changes customer state to 1
      cout << "Barber " << this->id << " calls Customer "<< myCustomer->id << "." <<endl;
    }
  
      //If we get here, the barber is now awake, but the customer needs to sit down.

      { //Lock waiting for barberState 2, waiting on the customer_sits() function
        Lock barberLock(barberMutex);
        while(this->barberState != 2){      //customer_sits changes barberState to 2
          pthread_cond_wait(this->barberCondition, barberMutex);
        }
      }//Unlock from State 2
      
      //If we get here, the barber is awake and a customer has sat in their chair.
      //That means that we now need to sleep for our service time.
      usleep(this->shop->service_time());

      myCustomer->finished(); //this changes customerState to 2
      cout << "Barber " << this->id << " finishes Customer " << myCustomer->id << "'s haircut." << endl;
      
      {//Lock waiting for state 3, waiting on payment() function
        Lock barberLock(barberMutex);
        while(this->barberState != 3){
          pthread_cond_wait(barberCondition, barberMutex);
        }
      } //Unlock from State 3

      myCustomer->payment_accepted();
      cout << "Barber " << this->id << " accepts payment from Customer " << myCustomer->id << "." << endl;
       //this changes customerState to 3.
      //WHAT DO I DO HERE NOW?
      //What do I call to ask for my next customer?
  }

  //Here we have broken out of the while loop
  //How do i work in closing_time?
}


  

//------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------Barber::closing_time-------------------------------------------------------
//------------------------------------------------------------------------------------------------------------------------
void Barber::closing_time(){
  //Not at all clear on where to use this fucntion or what to keep inside it.

}

//------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------Barber::awaken-------------------------------------------------------
//------------------------------------------------------------------------------------------------------------------------
void Barber::awaken(Customer* customer) {
  Lock barberLock(barberMutex);
  //cout << "Customer " << customer->id << " wakes Barber " << this->id << "." << endl;
  //no print statements in functions, only in run functions
  assignedCustomer = customer;
  barberState = 1;
  pthread_cond_signal(this->barberCondition);
}

//------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------Barber::customer_sits-------------------------------------------------------
//------------------------------------------------------------------------------------------------------------------------
void Barber::customer_sits() {
  Lock lock(barberMutex);
  //cout << "Customer " << this->assignedCustomer->id << " sits in Barber" << this->id << "'s chair." << endl;
  barberState = 2;
  pthread_cond_signal(this->barberCondition);

}

//------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------Barber::payment-------------------------------------------------------
//------------------------------------------------------------------------------------------------------------------------
void Barber::payment() {
  Lock barberLock(barberMutex);
  //cout << "Customer " << this->assignedCustomer->id << " gets up and proffers payment to barber " << this->id << "." << endl;
  //cout << "Do we make it here?" << endl;
  barberState = 3;
  pthread_cond_signal(this->barberCondition);
}

//------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------Customer::Customer-------------------------------------------------------
//------------------------------------------------------------------------------------------------------------------------
Customer::Customer(Shop* shop, int id):id(id){
  this->shop = shop;

    //allocate memory for customer mutex
  customerMutex = (pthread_mutex_t *) malloc(sizeof(pthread_mutex_t));
  *customerMutex = PTHREAD_MUTEX_INITIALIZER;

  //allocating memory for the customer conditionvariable
  customerCondition = (pthread_cond_t * )malloc(sizeof(pthread_cond_t));
  *customerCondition = PTHREAD_COND_INITIALIZER;
}

//------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------Customer::~Customer-------------------------------------------------------
//------------------------------------------------------------------------------------------------------------------------
Customer::~Customer() {

}

//------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------Customer::run-------------------------------------------------------
//------------------------------------------------------------------------------------------------------------------------
void Customer::run() {
  Shop::BarberOrWait barberOrWaitResponse; //stores the BarberOrWait object that is returned by arrives.
  
  Barber *myBarber;

  //The shop lock mutex makes this operation safe without its own lock.
  barberOrWaitResponse = this->shop->arrives(this);

  if(barberOrWaitResponse.barber != nullptr){    //There is a sleeping barber, so we call the awaken function.
      myBarber = barberOrWaitResponse.barber;
      
      myBarber->awaken(this);


  }else if(barberOrWaitResponse.chair_available){
    {//wait for the barber to call customer::next_customer
      Lock lock(customerMutex);
      while(customerState != 1){ //next_customer sets customerState to 1
        pthread_cond_wait(customerCondition, customerMutex);
      }
      //Customer::next_customer is called here

      //want to set local barber to customer obj barber
      myBarber = this->assignedBarber;
    }
  }else{ //If we land here, then there are no barbers and no chairs.
    //leave
    cout << "Customer " << this->id << " leaves without getting a haircut." << endl;
    return;
  }
    myBarber->customer_sits(); //this chnages barberState to 2.
    cout << "Customer " << this->id << " sits in Barber " << myBarber->id << "'s chair." << endl;
     
      {
        Lock customerLock(customerMutex); 
        while(customerState != 2){ //customerState is set to 2 in the finished function
          pthread_cond_wait(customerCondition, customerMutex);
        }
      }

      //Barber has finished servicing the customer
      //It is now time for the customer to pay

      myBarber->payment();
      cout << "Customer " << this->id << " gets up and proffers payment to barber " << myBarber->id << "." << endl;

      {
        Lock lock(customerMutex);
        while(customerState != 3){ //waiting on payment_accepted function.
          pthread_cond_wait(customerCondition, customerMutex);
        }
      }

      //at this point, the customer has gotten their haircut and paid.
      cout << "Customer " << this->id << " leaves statisfied." << endl;
      return;
  }




//------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------Customer::next_customer-------------------------------------------------------
//------------------------------------------------------------------------------------------------------------------------
void Customer::next_customer(Barber* barber) {
  Lock lock(customerMutex);
  this->assignedBarber = barber;
  customerState = 1;
  pthread_cond_signal(this->customerCondition);
  
  /*if (this->shop->customerQueue.empty() == true){ //If there are no more customers in the cusotmerQueue
    cout << "Customer " << this->id << " leaves statisfied." << endl;
    customerState = 3;  //Have this state terminate the customer.
    return;
  }

  else{
    int nextCustomerID = this->shop->customerQueue.front()->id;
    cout << "Barber " << this->assignedBarber->id << " calls Customer "<< nextCustomerID << "." <<endl;
    //Here I am just printing out the next customer. In the other next_customer function, I actually assign barber to customer.
    return;
  }*/

}


//------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------Customer::finished-------------------------------------------------------
//------------------------------------------------------------------------------------------------------------------------
void Customer::finished() {
  Lock lock (customerMutex);
  //cout << "Barber " << this->assignedBarber->id << " finishes Customer " << this->id << "'s haircut." << endl;
  customerState = 2;
  pthread_cond_signal(this->customerCondition);
}

//------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------Customer::payment_accepted-------------------------------------------------------
//------------------------------------------------------------------------------------------------------------------------
void Customer::payment_accepted() {
  Lock lock(customerMutex);
  customerState = 3;
  pthread_cond_signal(this->customerCondition);
}


void usage() {
  cerr
    << "usage: "
    << PROG_NAME
    << " <nbarbers>"
    << " <nchairs>"
    << " <avg_service_time>"
    << " <service_time_std_deviation>"
    << " <avg_customer_arrival_time>"
    << " <duration>"
    << endl;
  exit(EXIT_FAILURE);
}


int main(int argc, char* argv[]) {
  PROG_NAME = argv[0];

  if (argc != 7) {
    usage();
  }
  int barbers = atoi(argv[1]);
  if (barbers <= 0) {
    usage();
  }
  int chairs = atoi(argv[2]);
  if (chairs < 0) {
    usage();
  }
  int service_time = atoi(argv[3]);
  if (service_time <= 0) {
    usage();
  }
  int service_deviation = atoi(argv[4]);
  if (service_time <= 0) {
    usage();
  }
  int customer_arrivals = atoi(argv[5]);
  if (customer_arrivals <= 0) {
    usage();
  }
  int duration = atoi(argv[6]);
  if (duration <= 0) {
    usage();
  }

  Shop barber_shop(barbers,
		   chairs,
		   service_time,
		   service_deviation,
		   customer_arrivals,
		   duration);
  barber_shop.run();

  return EXIT_SUCCESS;
}
