// barbers.cc
//
// Simulate the sleeping barbers problem.
//
// Author: Morris Bernstein
// Copyright 2019, Systems Deployment, LLC.
#include <algorithm>
#include <cassert>
#include <chrono>
#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <pthread.h>
#include <queue>
#include <random>
#include <time.h>
#include <unistd.h>

using namespace std;

const char* PROG_NAME = "";

bool shopOpen = true; //determined if the shop is opened or is closed.

class Shop;
class Barber;
class Customer;

class Lock {
public:
  Lock(pthread_mutex_t* mutex): mutex(mutex) {
    int rc = pthread_mutex_lock(this->mutex);
    if (rc < 0) {
      perror("can't lock mutex");
      exit(EXIT_FAILURE);
    }
  }

  ~Lock() {
    int rc = pthread_mutex_unlock(mutex);
    if (rc < 0) {
      perror("can't unlock mutex");
      exit(EXIT_FAILURE);
    }
  }

private:
  pthread_mutex_t* mutex;
};

class Shop {
public:
  struct BarberOrWait {
    Barber* barber;		// Barber is available
    bool chair_available;	// If barber isn't available,
				// waiting chair is available.
  };

  // Constructor initializes shop and creates Barber threads (which
  // will immediately start calling next_customer to fill the
  // collection of sleeping barbers).
  Shop(int n_barbers, unsigned waiting_chairs, int average_service_time,
        int service_time_deviation, int average_customer_arrival, int duration);

  // Main thread: open the shop and spawn customer threads until
  // closing time.  Report summary statistics for the day.
  void run();

  // Customer thread announces arrival to shop. If the collection of
  // currently sleeping barbers is not empty, remove and return one
  // barber from the collection. If all the barbers are busy and there
  // is an empty chair in the waiting room, add the customer to the
  // waiting queue and return {nullptr, true}.  Otherwise, the
  // customer will leave: return {nullptr, false}.
  BarberOrWait arrives(Customer* customer);

  // Barber thread requests next customer.  If no customers are
  // currently waiting, add the barber to the collection of
  // currently sleeping barbers and return nullptr.
  Customer* next_customer(Barber* barber);

  // Return random service time.
  int service_time();

  // Return random customer arrival.
  int customer_arrival_time();

private:

  vector<pthread_t*> barber_threads;
  vector<pthread_t*> customer_threads;
  struct timespec time_limit;

  int customers_served_immediately;
  int customers_waited;
  int customers_turned_away;
  int customers_total;

  //The number of barbers in the shop
  int numBarbersWorking;
  //The number of waiting chairs we have
  unsigned waitingChairs;
  
  //stores average service time to use with the service_time()
  int averageServiceTime;
  
  //stores std. deviation to use with the service_time()
  int serviceTimeDeviation;
  
  //generated by the customer_arrival_time()
  int averageCustomerArrival;
  
  //length of the simulation/run
  int simulationDuration;

  pthread_mutex_t *shopMutex;       //Mutex for shop operations.

  queue<Barber*>   barberQueue;        //A queue of barbers. When this queue is full, all the barbers are asleep
  queue<Customer*> customerQueue;     //The waiting chairs/queue for customers.  
};


class Barber {
public:
  Barber(Shop* shop, int id);

  // Barber thread function.
  void run();

  // Shop tells barber it's closing time.
  void closing_time();

  // Customer wakes up barber.
  void awaken(Customer* customer);

  // Customer sits in barber's chair.
  void customer_sits();

  // Customer proffers payment.
  void payment();

  //Helper function to have the customer thread signal barber thread
  //Signal is: the customer is gone, it is safe to proceed.
  void cleanChair();

  const int id;
  

private:
  Shop* shop;

  pthread_mutex_t *barberMutex;       //Mutex for barber operations.
  pthread_cond_t *barberCondition;    //Condition (signal) for barber operations
  int barberState = 0;                //to determine the state that a barber is in
  Customer* assignedCustomer;         //Customer* that points to customer this barber is working on

  bool closed = false;

};


class Customer {
public:
  Customer(Shop* shop, int id);
  ~Customer();

  // Customer thread function.
  void run();

  // Barber calls this customer after checking the waiting-room
  // queue (customer should be waiting).
  void next_customer(Barber* barber);

  // Barber finishes haircut (Customer should be receiving haircut).
  void finished();

  // Barber has accepted payment for service.
  void payment_accepted();

  const int id;
  Barber* assignedBarber;                     //Barber* that points to the barber working with this customer object.


private:
  Shop* shop;
  pthread_mutex_t *customerMutex;      //mutex for cusotmer operations
  pthread_cond_t *customerCondition;   //condition (signal) for customer operations
  int customerState = 0;                      //internal variable to determine the state of the customer
};


// Barber thread.  Must be joined by Shop thread to allow shop to
// determine when barbers have left.
void* run_barber(void* arg) {
  Barber* barber = reinterpret_cast<Barber*>(arg);
  barber->run();
  return nullptr;
}


// Customer thread.  Runs in detatched mode so resources are
// automagically cleaned up when customer leaves shop.
void* run_customer(void* arg) {
  Customer* customer = reinterpret_cast<Customer*>(arg);
  customer->run();
  delete customer; //Deallocating memory for the customer
  return nullptr;
}


//The below two functions are for debug purposes only.
//They take a queue, copy it, and print the contens of the queue.
void printCustomerQueue(queue<Customer*> q){
  cout << "Customer Queue: ";
  while(!q.empty()){
    cout << " " << q.front()->id;
    q.pop();
  }
  cout << endl;
}

void printBarberQueue(queue<Barber*> q){
  cout << "Barber Queue: ";
  while(!q.empty()){
    cout << " " << q.front()->id;
    q.pop();
  }
  cout << endl;
}

//------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------Shop::Shop-------------------------------------------------------
//------------------------------------------------------------------------------------------------------------------------
Shop::Shop(int n_barbers, unsigned int waiting_chairs, int average_service_time, int service_time_deviation,
          int average_customer_arrival, int duration){

  //Ive created all these private varibles inside the Shop class to hold the values we use to initialize.
  numBarbersWorking = n_barbers;
  waitingChairs = waiting_chairs;
  averageServiceTime = average_service_time;
  serviceTimeDeviation = service_time_deviation;
  averageCustomerArrival = average_customer_arrival;
  simulationDuration = duration;

  shopMutex = (pthread_mutex_t *) malloc(sizeof(pthread_mutex_t));
  *shopMutex = PTHREAD_MUTEX_INITIALIZER;

  int rc = clock_gettime(CLOCK_REALTIME, &time_limit);
  if (rc < 0) {
    perror("reading realtime clock");
    exit(EXIT_FAILURE);
  }
  // Round to nearest second
  time_limit.tv_sec += duration + (time_limit.tv_nsec >= 500000000); //500,000,000. 500 millon nano seconds = 0.5 second
  time_limit.tv_nsec = 0;


  for(int i = 0; i < numBarbersWorking; i++){
    Barber *newBarber = new Barber(this,i); //create barber objects

    pthread_t* barberThread = reinterpret_cast<pthread_t*>(calloc(1, sizeof(pthread_t)));
      int rc = pthread_create(barberThread, nullptr,run_barber, reinterpret_cast<void *>(newBarber));

      if (rc != 0) {
        errno = rc;
        perror("Failed creating barberThread pthread");
        exit(EXIT_FAILURE);
      }
      else{

        barber_threads.push_back(barberThread);
      }
  }
  //Initialize our metric variables to 0
  customers_served_immediately = 0;
  customers_waited = 0;
  customers_turned_away = 0;
  customers_total = 0;
}


//------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------Shop::run-------------------------------------------------------
//------------------------------------------------------------------------------------------------------------------------
void Shop::run(){
  cout << "the shop opens" << endl;
  //int numberOfTotalCustomers = 0;

  for (int next_customer_id = 0; ; next_customer_id++) {
    struct timespec now;
    int rc = clock_gettime(CLOCK_REALTIME, &now);
    if (rc < 0) {
      perror("reading realtime clock");
      exit(EXIT_FAILURE);
    }
    if (now.tv_sec >= time_limit.tv_sec) {
      // Shop closes.
      //numberOfTotalCustomers = next_customer_id; //When we break the loop, record how many customers we had.
      shopOpen = false;
      break;
    }

    // Wait for random delay, then create new Customer thread.
    usleep(customer_arrival_time());//waiting for a random delay based on the customer_arrival_time function
    //cout << "New Customer. Customer #: "<< next_customer_id <<endl;

    //Here I am going to create my customerThreads
    //When I call pthtread_create, I am going to make sure I create my customer threads in detached mode.
    //Creating a new Customer object.
    Customer *customer = new Customer (this,next_customer_id);

    pthread_t* customerThread = reinterpret_cast<pthread_t*>(calloc(1, sizeof(pthread_t)));
      int customerThreadRC = pthread_create(customerThread, nullptr,run_customer, reinterpret_cast<void *>(customer));
      
      if (customerThreadRC != 0) {
        errno = customerThreadRC;
        perror("Failed creating cusotmerThread pthread");
        exit(EXIT_FAILURE);
      }else{
          pthread_detach(*customerThread);
      }
  }
  
  cout << endl;
  cout << "the shop closes" << endl;
  shopOpen = false;
  cout << shopOpen << endl;
  cout << endl;  

  for (auto thread: barber_threads) {
    pthread_join(*thread, nullptr);
  }

  customers_total = customers_served_immediately + customers_waited + customers_turned_away;

  cout << endl;
  cout << "Customers served immediately: " << customers_served_immediately << endl;
  cout << "Customers waited: " << customers_waited << endl;
  cout << "Total customers served: " << (customers_served_immediately + customers_waited) << endl;
  cout << "Customers turned away: " << customers_turned_away << endl;
  cout << "Total customers: " << customers_total << endl;
}

//------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------Shop::arrives--------------------------------------------------------------
//------------------------------------------------------------------------------------------------------------------------
Shop::BarberOrWait Shop::arrives(Customer* customer) {
  Lock shopLock(shopMutex);                 //Lock the shop mutex

  Barber* tempBarber;                       //Makes returning a Barber* a little cleaner

  if(!barberQueue.empty()){                 //If we break in here, there is a barber available as he is sleeping
    tempBarber = barberQueue.front();       //Connect the barber and customer objects.
    barberQueue.pop();                      //Pop the front of the barber queue
    this->customers_served_immediately++;   //Increment proper counter
    
    return BarberOrWait{tempBarber,true};   //Return
  }

  //If there is no available barber, check the waiting chairs
  else if(barberQueue.empty() == true && (customerQueue.size() < waitingChairs)){
    //in the else if statemenet, I am asking the following:
            //IF there are no sleeping barbers AND
            //the customerQueue is less than the number of waiting chairs AND
            //the number of barbers working
            //THEN, we can add a customer to the customerQueue.

    customerQueue.push(customer);           //Add the customer to customerQueue
    this->customers_waited++;               //Increment the fact that we had a customer wait.

    return BarberOrWait{nullptr,true};           
  }
                                            //If we get here, there are no barbers
                                            //And, there are no waiting chairs.
    this->customers_turned_away++;          //Incremenet counter
    return BarberOrWait{nullptr, false};
}


//------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------Shop::next_customer-------------------------------------------------------
//------------------------------------------------------------------------------------------------------------------------
Customer* Shop::next_customer(Barber* barber) {
  Lock shopLock(shopMutex);       //We are reading/writing shared queues. Need to lock shop mutex.

  Customer* returnCustomer;       //To make returning easier

  if(!customerQueue.empty()){               //If the customerQueue IS NOT empty (there are no customers)
    returnCustomer = customerQueue.front(); //return the front of the queue
    customerQueue.pop();                    //Remove the customer from the customerQueue

    return returnCustomer;

  }else{                                    //If the customerQueue IS empty, barber takes a nap.
    this->barberQueue.push(barber);         //Return the barber to the barberQueue
    
    return nullptr;                         //Barber responds that he is going to sleep
  }
}

//------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------Shop::service_time-------------------------------------------------------
//------------------------------------------------------------------------------------------------------------------------
int Shop::service_time() {
  
  int serviceTime = 0;
  
  random_device randomDevice;
  default_random_engine generator(randomDevice());
  normal_distribution<double> normalDistribution((averageServiceTime),(serviceTimeDeviation)); 
  
  //Multiplying by 1000, as I will end up calling micro sleep (usleep)
  serviceTime = normalDistribution(generator)*1000;

  //minimumServiceTime, as dicated by assignment 2 instructions
  int minimumServiceTime = (0.8)*averageServiceTime*1000;


  // cout << endl;
  // cout << "averagreSergiceTime: " << averageServiceTime << endl;
  // cout << "serviceTimeDeviation: " << serviceTimeDeviation << endl;
  // cout << "serviceTime: " << serviceTime << endl;
  // cout << "minimumServiceTime: " << minimumServiceTime << endl;
  // cout << endl;

  if(serviceTime < minimumServiceTime){ //Setting the floor for service time.
    return minimumServiceTime;
  }

  return serviceTime;
}


//------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------Shop::customer_arrival_time-------------------------------------------------------
//------------------------------------------------------------------------------------------------------------------------
int Shop::customer_arrival_time() {
  int customerArrival = 0;


  random_device randomDevice;
  default_random_engine generator(randomDevice());
  poisson_distribution<int> poissonDistribution((averageCustomerArrival));

  //Multiplying by 1000, as I will end up calling micro sleep (usleep)
  customerArrival = poissonDistribution(generator)*1000;

  //cout << "customerArrival: " << customerArrival << endl;

  return customerArrival;
}


//------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------Barber::Barber-------------------------------------------------------
//------------------------------------------------------------------------------------------------------------------------
Barber::Barber(Shop* shop, int id):id(id){
  this->shop = shop;

  //allocate memory for Barber mutex and initializing
  barberMutex = (pthread_mutex_t *) malloc(sizeof(pthread_mutex_t));
  *barberMutex = PTHREAD_MUTEX_INITIALIZER;

  //allocating memory for the barber condition variable and initializing
  barberCondition = (pthread_cond_t * )malloc(sizeof(pthread_cond_t));
  *barberCondition = PTHREAD_COND_INITIALIZER;

}

//------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------Barber::run-------------------------------------------------------
//------------------------------------------------------------------------------------------------------------------------
void Barber::run() {                                   
  cout << "Barber " << this->id << " arrives for work" << endl;
  int remainingCustomers = 0;   //Variable to make sure we clear out the customerQueue

  while (true){                 //Barbers work until the termination of the shop.
    this->barberState = 0;      //Resetting the state variable for a barber on each loop

    if(!shopOpen){
      remainingCustomers++;

      if(remainingCustomers >= 1){  //Making sure we clear out the customerQueue
        break;                      //End the Barber::run while loop    
      }
    }
    
    Customer *myCustomer;       //Local Customer* to assign customer to barber

    //We dont need a lock here, as the next_customer function manipualtes data of the shop.
    myCustomer = shop->next_customer(this);

    if(myCustomer == nullptr){    //If we dont have a customer. we wait on being awoken.
      Lock lock (barberMutex);

      cout << "Barber " << this->id << " takes a nap" << endl;

      while(barberState != 1 && shopOpen){
          pthread_cond_wait(barberCondition, barberMutex);
      }
      //By this point, the cusotmer has called awaken.
      //We only get barberState = 1 when awaken is called in the customer thread

      myCustomer = this->assignedCustomer;
    
    } else{    
      //this means you have a customer in the shop.
      //the shop has told you who your customer is and you are awake!
      //so there is a customer in the waiting room chair
      //this means that shop::bext_customer returned a valid customer pointer.

      myCustomer->next_customer(this); //This changes customer state to 1

      cout << "Barber " << this->id << " calls Customer "<< myCustomer->id << "." <<endl;
    }
  
      //If we get here, the barber is now awake, but the customer needs to sit down.
      { //Lock waiting for barberState 2, waiting on the customer_sits() function
        Lock barberLock(barberMutex);
        while(this->barberState != 2){      //customer_sits changes barberState to 2
          pthread_cond_wait(this->barberCondition, barberMutex);
        }
      }//Unlock from State 2
      
      //If we get here, the barber is awake and a customer has sat in their chair.
      //That means that we now need to sleep for our service time.
      usleep(this->shop->service_time());

      myCustomer->finished(); //this changes customerState to 2

      cout << "Barber " << this->id << " finishes Customer " << myCustomer->id << "'s haircut." << endl;
      
      {//Lock waiting for state 3, waiting on payment() function
        Lock barberLock(barberMutex);
        while(this->barberState != 3){
          pthread_cond_wait(barberCondition, barberMutex);
        }
      } //Unlock from State 3

      myCustomer->payment_accepted(); //this changes customerState to 3.

      cout << "Barber " << this->id << " accepts payment from Customer " << myCustomer->id << "." << endl;


  }

  cout << "Barber " << this->id << " leaves for home." << endl;
  return; //Not necessary, but fun to write return.
  //Especially after how much I struggled with this function.
}

//------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------Barber::closing_time-------------------------------------------------------
//------------------------------------------------------------------------------------------------------------------------
void Barber::closing_time(){
}

//------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------Barber::awaken-------------------------------------------------------
//------------------------------------------------------------------------------------------------------------------------
void Barber::awaken(Customer* customer) {
  Lock barberLock(barberMutex);
  assignedCustomer = customer;
  barberState = 1;
  pthread_cond_signal(this->barberCondition);
}

//------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------Barber::customer_sits-------------------------------------------------------
//------------------------------------------------------------------------------------------------------------------------
void Barber::customer_sits() {
  Lock lock(barberMutex);
  barberState = 2;
  pthread_cond_signal(this->barberCondition);

}

//------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------Barber::payment-------------------------------------------------------
//------------------------------------------------------------------------------------------------------------------------
void Barber::payment() {
  Lock barberLock(barberMutex);
  barberState = 3;
  pthread_cond_signal(this->barberCondition);
}


//------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------Customer::Customer-------------------------------------------------------
//------------------------------------------------------------------------------------------------------------------------
Customer::Customer(Shop* shop, int id):id(id){
  this->shop = shop;

  //allocate memory for customer mutex and initalize
  customerMutex = (pthread_mutex_t *) malloc(sizeof(pthread_mutex_t));
  *customerMutex = PTHREAD_MUTEX_INITIALIZER;

  //allocating memory for the customer condition variable and initalize
  customerCondition = (pthread_cond_t * )malloc(sizeof(pthread_cond_t));
  *customerCondition = PTHREAD_COND_INITIALIZER;
}

//------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------Customer::~Customer-------------------------------------------------------
//------------------------------------------------------------------------------------------------------------------------
Customer::~Customer() {

}

//------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------Customer::run-------------------------------------------------------
//------------------------------------------------------------------------------------------------------------------------
void Customer::run() {
  Shop::BarberOrWait barberOrWaitResponse; //stores the BarberOrWait object that is returned by arrives.
  
  Barber *myBarber;

  //The shop lock mutex makes this operation safe without its own lock.
  barberOrWaitResponse = this->shop->arrives(this);

  if(barberOrWaitResponse.barber != nullptr){    //There is a sleeping barber, so we call the awaken function.
    myBarber = barberOrWaitResponse.barber;
    myBarber->awaken(this);
    cout << "Customer " << this->id << " wakes Barber " << myBarber->id << "." << endl;

  }else if(barberOrWaitResponse.chair_available){

    {//wait for the barber to call customer::next_customer
      Lock lock(customerMutex);
      while(customerState != 1){ //next_customer sets customerState to 1
        pthread_cond_wait(customerCondition, customerMutex);
      }

      //Customer::next_customer is called here
      cout << "Customer " << this->id << " takes a seat in the waiting room." << endl;

      //want to set local barber to customer obj barber
      myBarber = this->assignedBarber;
    }
  }else{ //If we land here, then there are no barbers and no chairs. So we leave.
    cout << "Customer " << this->id << " leaves without getting a haircut." << endl;
    return;
  }
    //If we get to here, then we have been assigned a barber.
    myBarber->customer_sits(); //this chnages barberState to 2.
    cout << "Customer " << this->id << " sits in Barber " << myBarber->id << "'s chair." << endl;
      {
        Lock customerLock(customerMutex); 
        while(customerState != 2){ //customerState is set to 2 in the finished function
          pthread_cond_wait(customerCondition, customerMutex);
        }
      }
      //Barber has finished servicing the customer
      //It is now time for the customer to pay
      myBarber->payment();
      cout << "Customer " << this->id << " gets up and proffers payment to barber " << myBarber->id << "." << endl;
      {
        Lock lock(customerMutex);
        while(customerState != 3){ //waiting on payment_accepted function.
          pthread_cond_wait(customerCondition, customerMutex);
        }
      }
      //at this point, the customer has gotten their haircut and paid.
      cout << "Customer " << this->id << " leaves statisfied." << endl;
      return;
}

//------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------Customer::next_customer-------------------------------------------------------
//------------------------------------------------------------------------------------------------------------------------
void Customer::next_customer(Barber* barber) {
  Lock lock(customerMutex);
  this->assignedBarber = barber;
  customerState = 1;
  pthread_cond_signal(this->customerCondition);
}


//------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------Customer::finished-------------------------------------------------------
//------------------------------------------------------------------------------------------------------------------------
void Customer::finished() {
  Lock lock (customerMutex);
  customerState = 2;
  pthread_cond_signal(this->customerCondition);
}

//------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------Customer::payment_accepted-------------------------------------------------------
//------------------------------------------------------------------------------------------------------------------------
void Customer::payment_accepted() {
  Lock lock(customerMutex);
  customerState = 3;
  pthread_cond_signal(this->customerCondition);
}


void usage() {
  cerr
    << "usage: "
    << PROG_NAME
    << " <nbarbers>"
    << " <nchairs>"
    << " <avg_service_time>"
    << " <service_time_std_deviation>"
    << " <avg_customer_arrival_time>"
    << " <duration>"
    << endl;
  exit(EXIT_FAILURE);
}


int main(int argc, char* argv[]) {
  PROG_NAME = argv[0];

  if (argc != 7) {
    usage();
  }
  int barbers = atoi(argv[1]);
  if (barbers <= 0) {
    usage();
  }
  int chairs = atoi(argv[2]);
  if (chairs < 0) {
    usage();
  }
  int service_time = atoi(argv[3]);
  if (service_time <= 0) {
    usage();
  }
  int service_deviation = atoi(argv[4]);
  if (service_time <= 0) {
    usage();
  }
  int customer_arrivals = atoi(argv[5]);
  if (customer_arrivals <= 0) {
    usage();
  }
  int duration = atoi(argv[6]);
  if (duration <= 0) {
    usage();
  }

  Shop barber_shop(barbers,
		   chairs,
		   service_time,
		   service_deviation,
		   customer_arrivals,
		   duration);
  barber_shop.run();

  return EXIT_SUCCESS;
}
